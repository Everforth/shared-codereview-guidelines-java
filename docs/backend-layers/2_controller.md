## Controller層（エンドポイント、リクエスト/レスポンス処理、DTO 等）

### 必須チェック項目：

- **APIエンドポイント設計**:
  - 既存のエンドポイントパターンに合わせた一貫性のあるRESTful設計
  - リソース指向のURL構造（動詞ではなく名詞を使用）
  - 適切なHTTPメソッドの使用（GET/POST/PUT/PATCH/DELETE）
  - ファイルとDTOを同一エンドポイントで受け取らず、ファイル受信用とメタデータ更新用のAPIを分離する
  - 常に固定値で良いパラメータは、APIパラメータとして公開せず内部で固定する
- **バリデーション/変換機構の活用**:
  - Spring MVCのバリデーション・型変換機構（例: Bean Validation、Converter/Formatter）を適切に使用しているか
  - 文字列型で受けると緩すぎる場合は、専用の型/enumやカスタムコンバータを使用して型安全性を確保する
  - 日付や数値のパースなど汎用的な処理は、既存のコンバータ/フォーマッタを活用する
- **DTOバリデーション設計**:
  - Bean Validationアノテーションを使用した入力検証の実装
  - 必須/任意フィールドの明確な定義
  - 適切な型制約とカスタムバリデーションルール
  - 文字列フィールドには文字数制限を設定する
- **APIリクエストのバリデーション厳格化**:
  - 無駄にoptionalやnullを付けない
  - 型なし入力（生の`Map<String, Object>`等）は必要不可欠な場合を除いて避ける
  - 自由なテキスト入力でない場合は広すぎるstring型を避け、専用の型/enumやコンバータで受ける
- **DTOの責務**:
  - バックエンド側で埋める項目はDTOに含めない
  - 外部システムの知識（外部APIのタグ形式等）をDTOに漏らさず、Service層で変換する
- **責務分離**: Controller/Serviceの役割が適切に分離されているか
- **入力値の正規化はController層の責務**: 0以下をnull/未指定値に変換する等の入力値正規化はvalidationの一部であり、Controller層で行う
- **エラー処理**: 適切なHTTPステータスコードを返し、意味のあるエラーメッセージを提供しているか
- **セキュリティ**: 認証・認可の設定が正しく適用されているか（グローバルなSpring Security設定を確認した上で判断する）
- **型設計**: 既存DTO/型定義を再利用し、Create/Update DTOのパターンを一貫して適用しているか

### パフォーマンス考慮点：

- 適切なキャッシュ戦略（TTL設定）

### 設計・命名規則：

- RESTfulなAPI設計を重要視しつつ既存のコードベースのエンドポイント命名規則に従う
- モジュール間で名前の衝突を避ける
- URLパラメータ名とEntityのプロパティ名を一致させる（例: Entityが`uuid`なら`:uuid`を使用）
- DTOのクラス名とファイル名にrequest/responseの役割を明示する

### OpenAPIドキュメンテーション：

- **基本方針**: `springdoc-openapi`でOpenAPIドキュメントを自動生成できるため、複雑でない限りアノテーションは避ける
- **アノテーション適用の判断基準**:
  - 変数名から用途が自明な場合: アノテーション不要
  - デフォルトで設定される値の場合: アノテーション不要
  - 変数名から解釈しづらい場合のみ: アノテーション（例: `@Schema(description = "...")`）でdescriptionを追加
  - エンドポイントのドキュメント: シンプルで理解しやすい場合は記述しない
- **推奨事項**:
  - DTOのプロパティ名は意味が明確になるよう命名し、不要なドキュメントを減らす
  - 複雑なビジネスロジックや特殊な制約がある場合のみ詳細な説明を追加

### この層で扱わないこと：

- Entity定義（DB層の責務）
- データベーススキーマ、マイグレーション（DB層の責務）
- ビジネスロジックの実装（Service層の責務）
- 外部APIとの通信処理（Service層の責務）
- CRUDの網羅性（その時点で必要な最低限の実装があれば良い）
