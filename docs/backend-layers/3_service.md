## Service層（ビジネスロジック、データ処理 等）

### 必須チェック項目：

- **ビジネスロジックの正確性**: データの加工、計算、判定処理が仕様通りに実装されているか
- **トランザクション境界**: データベーストランザクションが適切なスコープで設定されているか
- **データ変換処理**: EntityからDTOへの変換、外部APIレスポンスの変換が適切か
- **Service間の依存関係**: 他のServiceへの依存が適切で、循環参照を避けているか
- **不要なモジュールのインポート削除**: 使用していないモジュールやライブラリがインポートされていないか
- **エラーハンドリング**: ビジネスロジック内で発生するエラーを適切に処理し、例外をスローしているか（HTTPステータスはControllerで決定）
- **責務分離**: Serviceがビジネスロジックのみに集中し、HTTP関連の処理を含んでいないか
- **重複コードの排除**: 類似のロジックが既存のコードに存在しないか確認し、再利用可能な共通関数やServiceを活用しているか
- **非同期処理**: 非同期処理を採用している場合（例: `@Async` / `CompletableFuture`）、完了時/例外時のハンドリングが明示的かつ一貫しているか
- **暗黙的な前提条件の排除**: メソッドが外部での事前チェックを前提としていないか、単体で正しく動作するか
- **型なし入力の回避**: 型を明示的に定義し、型なしの生データ構造（例: `Map<String, Object>`）は必要不可欠な場合を除き避ける
- **不適切なキャストの回避**: 暗黙的な前提で型エラーを握りつぶさず、正規の方法で値を取得する
- **DTOにロジックを含めない**: データ変換やフィルタリングはServiceの責務であり、DTOのコンストラクタで行わない
- **カラム名とデータの整合性**: カラム名が示す意味と実際に保存されるデータを一致させる

### パフォーマンス考慮点：

- バッチ処理での一括操作
- 適切なキャッシュ戦略（TTL設定）
- 不要なDB呼び出しの削減
- upsertパターンの適切な使用: race condition対策の細かいコードは全体に広げず、本当にhigh volumeが来る箇所のみに限定する

### JPA/Hibernate使用方針：

- Spring Data JPAのRepository APIを優先: 複雑なクエリが必要な場合を除き、低レベルなクエリ構築よりRepository APIを優先する
- `save`/`persist` がループや高負荷経路で使われている場合、「🟨 確認」として指摘し、過剰なSQLを避けるためにHibernateのバッチ処理やflush戦略を確認する。
- ページネーション機構の活用: パフォーマンス最適化が必須の箇所を除き、Spring Dataの`Page`/`Pageable`等で保守性を確保する

### 設計・命名規則：

- 特殊な実装には必ずコメントで理由を明記
- モジュール間で名前の衝突を避ける
- 型変換ロジックの配置: 型変換ロジックは、関連するDTO/ドメイン型の近くにMapper/Converterクラスとして配置する

### この層で扱わないこと：

- Entity定義、データベーススキーマ（DB層の責務）
- JPA/Hibernateのクエリ構築・チューニング詳細（DB層の責務、Serviceでは「どのデータを取得するか」のみ）
- DTOの定義とバリデーション（Controller層の責務）
- HTTPリクエスト/レスポンス処理（Controller層の責務）
- HTTPステータスコードの決定（Controller層の責務）
- 認証・認可（Spring Security）の設定（Controller層の責務）
- ルーティング、エンドポイント定義（Controller層の責務）
